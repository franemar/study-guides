<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <figure>
      <table>
        <thead>
          <tr>
            <th></th>
            <th>
              <p>prolog</p>
            </th>
            <th>
              <p>elixir</p>
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <p>version used<br></p>
            </td>
            <td>
              <p>SWI Prolog 7.2</p>
            </td>
            <td>
              <p>1.3</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>show version<br></p>
            </td>
            <td>
              <p>$ swipl –version</p>
            </td>
            <td>
              <p>$ elixir -v</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>grammar and invocation</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>hello world</p>
            </td>
            <td>
              <p>$ cat ./hello.pl<br>hello :-<br>format('Hello, World!~n'),<br>halt.<br><br>$ swipl -q -t hello -f ./hello.pl<br>Hello, World!</p>
            </td>
            <td>
              <p>$ cat hello.exs<br>IO.puts "Hello, World!"<br><br>$ elixir hello.exs<br>Hello, World!</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>compiler</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>bytecode compiler<br></p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>interpreter</p>
            </td>
            <td>
              <p>$ cat arg-analyzer<br>main :-<br>current_prolog_flag(argv, Args),<br>( Args = [Arg]<br>-> format('argument was: ~w~n', [Arg])<br>; format('Usage: arg-analyzer ARG~n') ).<br><br>:- main, halt(0).<br><br>$ swipl -s arg-analyzer foo<br>argument was: foo</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>shebang</p>
            </td>
            <td>
              <p>$ cat arg-analyzer<br>#!/usr/bin/env swipl<br><br>main :-<br>current_prolog_flag(argv, Args),<br>( Args = [Arg]<br>-> format('argument was: ~w~n', [Arg])<br>; format('Usage: arg-analyzer ARG~n') ).<br><br>:- main, halt(0).<br><br>$ ./arg-analyzer foo<br>argument was: foo</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>repl<br></p>
            </td>
            <td>
              <p>$ swipl</p>
            </td>
            <td>
              <p>$ iex</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>block delimiters</p>
            </td>
            <td>
              <p>( )</p>
            </td>
            <td>
              <pre>do ; end</pre>
            </td>
          </tr>
          <tr>
            <td>
              <p>statement terminator<br></p>
            </td>
            <td>
              <p>.</p>
            </td>
            <td>
              <p>print("Hello, world!")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>end-of-line comment<br></p>
            </td>
            <td>
              <p>% a comment</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>multiple line comment</p>
            </td>
            <td>
              <p>/* comment line<br>comment line */</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>variables and expressions</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>variable identifier</p>
            </td>
            <td>
              <p>upper case letter followed by alphanumeric characters and underscores</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>write once variable</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>assignment | X = 3.<br>4 = Y. | x = 3</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>parallel assignment</p>
            </td>
            <td>
              <p>(X, Y) = (1, 2).<br>[X, Y] = [1, 2].<br>{X, Y} = {1, 2}.<br>foo(X, Y) = foo(1, 2).</p>
            </td>
            <td>
              <p>{x, y} = {1, 2}<br>[z, w] = [1, 2]</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>non-referential identifier</p>
            </td>
            <td>
              <p>lower case letter followed by alphanumeric characters; can also include underscore: _</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>quoted non-referential identifier</p>
            </td>
            <td>
              <p>any printable characters inside single quotes; use backslash to escape a single quote.</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>conditional expression | X = −3, (<br>X > 0 -> Result = 1;<br>X = 0 -> Result = X;<br>X &lt; 0 -> Result = −1<br>).</p>
            </td>
            <td>
              <p>if x > 0 do 1 else if x &lt; 0 do −1 else 0 end end</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>case</p>
            </td>
            <td>
              <p>( X = 1 -> Result = true<br>; X = 0 -> Result = false ).<br>or:<br>member(X-Result, [<br>1-true,<br>0-false]).</p>
            </td>
            <td>
              <p>case x do<br>1 -> true<br>0 -> false<br>end</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>arithmetic and logic</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>true and false<br></p>
            </td>
            <td>
              <p>true fail</p>
            </td>
            <td>
              <p>true false</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>falsehoods<br></p>
            </td>
            <td></td>
            <td>
              <p>false nil</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>logical operators</p>
            </td>
            <td>
              <p>, ; ?? ??</p>
            </td>
            <td>
              <p># arguments must be boolean:<br>and or not<br><br># arguments of any type permitted:<br>&amp;&amp;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>short circuit operators</p>
            </td>
            <td></td>
            <td>
              <p>and or &amp;&amp;</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>relational operators</p>
            </td>
            <td>
              <p>=:= \= &lt; > =&lt; >=</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>arithmetic expression</p>
            </td>
            <td>
              <p>X is 2 + 2.</p>
            </td>
            <td>
              <p>2 + 2</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>arithmetic operators<br><br>addition, subtraction, multiplication, float division, integer division, remainder</p>
            </td>
            <td>
              <ol>
                <li>
                  <ul>
                    <li>* / // mod</li>
                  </ul>
                </li>
              </ol>
            </td>
            <td>
              <ol>
                <li>
                  <ul>
                    <li>* / div rem<br></li>
                  </ul>
                </li>
              </ol>
              <p><br>div and rem are functions, not operators</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>integer division</p>
            </td>
            <td>
              <p>X is 7 // 3.</p>
            </td>
            <td>
              <p>div 7, 3<br>div(7, 3)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>integer division by zero</p>
            </td>
            <td>
              <p>zero_divisor error</p>
            </td>
            <td>
              <p>raises ArithmeticError</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>float division<br></p>
            </td>
            <td>
              <p>X is 7 / 3.</p>
            </td>
            <td>
              <p>7 / 3</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>float division by zero</p>
            </td>
            <td>
              <p>zero_divisor error</p>
            </td>
            <td>
              <p>raises ArithmeticError</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>power<br></p>
            </td>
            <td>
              <p>X is 2**32.</p>
            </td>
            <td>
              <dl>
                <dt></dt>
                <dd>
                  <div>math.pow(2, 32)</div>
                </dd>
              </dl>
            </td>
          </tr>
          <tr>
            <td>
              <p>sqrt<br></p>
            </td>
            <td>
              <p>X is sqrt(2).</p>
            </td>
            <td>
              <dl>
                <dt></dt>
                <dd>
                  <div>math.sqrt(2)</div>
                </dd>
              </dl>
            </td>
          </tr>
          <tr>
            <td>
              <p>sqrt −1<br></p>
            </td>
            <td>
              <p>arithmetic evaluation error: undefined</p>
            </td>
            <td>
              <p>raises ArithmeticError</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>transcendental functions</p>
            </td>
            <td>
              <p>exp log<br>sin cos tan<br>asin acos atan<br>atan2</p>
            </td>
            <td>
              <dl>
                <dt></dt>
                <dd>
                  <div>math.exp :math.log<br>:math.sin :math.cos :math.tan<br>:math.asin :math.acos :math.atan<br>:math.atan2</div>
                </dd>
              </dl>
            </td>
          </tr>
          <tr>
            <td>
              <p>float truncation</p>
            </td>
            <td>
              <p>truncate round floor ceiling</p>
            </td>
            <td>
              <p># 2, 3:<br>trunc(2.7)<br>round(2.7)<br><br># 2.0, 3.0:<br>Float.floor(2.7)<br>Float.ceil(2.7)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>absolute value</p>
            </td>
            <td>
              <p>X is abs(-3).<br>X is abs(-3.2).</p>
            </td>
            <td>
              <p>abs(-3)<br>abs(-3.2)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>integer overflow</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>float literal with exponent</p>
            </td>
            <td>
              <p>2.0e2<br>-2.0E-2</p>
            </td>
            <td>
              <p>2.0e2<br>-2.0e-2</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>random number</p>
            </td>
            <td>
              <p>X is random(100).</p>
            </td>
            <td>
              <dl>
                <dt></dt>
                <dd>
                  <div>random.uniform<br>:random.uniform(100)</div>
                </dd>
              </dl>
            </td>
          </tr>
          <tr>
            <td>
              <p>random seed<br></p>
            </td>
            <td>
              <p>set_random(seed(17)).</p>
            </td>
            <td>
              <dl>
                <dt></dt>
                <dd>
                  <div>random.seed(17, 17, 17)</div>
                </dd>
              </dl>
            </td>
          </tr>
          <tr>
            <td>
              <p>result of not seeding</p>
            </td>
            <td>
              <p>seeded using /dev/random or system time</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>bit operators</p>
            </td>
            <td>
              <p>X is 5 &lt;&lt; 1.<br>X is 5 >> 1.<br>X is 5 /\ 1.<br>X is 5 \/ 1.<br>X is 5 xor 1.<br>X is \ 5.</p>
            </td>
            <td>
              <p>import Bitwise<br><br>5 &lt;&lt;&lt; 1<br>5 >>> 1<br>5 &amp;&amp;&amp; 1<br>5</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>binary, octal, and hex literals</p>
            </td>
            <td>
              <p>2'101010<br>8'52<br>16'2A</p>
            </td>
            <td>
              <p>0b101010<br>0o52<br>0x2A</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>strings</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>string literal</p>
            </td>
            <td>
              <p>list of characters:<br>"don't say \"no\""<br><br>quoted atom:<br>'don\'t say "no"'</p>
            </td>
            <td>
              <p>"don't say \"no\""</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>newline in literal</p>
            </td>
            <td>
              <p>yes; and \n notation can also be used</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>character escapes</p>
            </td>
            <td>
              <p>\a \b \e \f \n \r \s \t \v \xhh…\ \uhhhh \Uhhhhhhhh \ooo \\ \' \"</p>
            </td>
            <td>
              <p>\" \' \\ \a \b \d \e \f \n \r \s \t \v \0<br>\xhh \uhhhh \u{h…}</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>concatenate</p>
            </td>
            <td>
              <p>append("one ", "two ", Y), append(Y, "three", X).</p>
            </td>
            <td>
              <p>"one " &lt;> "two " &lt;> "three"</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>replicate<br></p>
            </td>
            <td>
              <p>list from single characters:<br>length(Hbar, 80), maplist(=('-'), Hbar).</p>
            </td>
            <td>
              <dl>
                <dt></dt>
                <dd>
                  <div>binary.copy("-", 80)</div>
                </dd>
              </dl>
            </td>
          </tr>
          <tr>
            <td>
              <p>trim<br>both sides, left side, right side</p>
            </td>
            <td>
              <p>normalize_space(string(Result), " lorem ").</p>
            </td>
            <td>
              <p>String.trim(" lorem ")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>pad<br>on right, on left, both sides</p>
            </td>
            <td>
              <p>format(string(Result), 'lorem~10|', []).<br>Result = "lorem ".<br><br>format(string(Result), '~tlorem~10|', []).<br>Result = " &amp;nbsp lorem".<br><br>format(string(Result), '~tlorem~t~10|', []).<br>Result = " lorem ".</p>
            </td>
            <td>
              <p>String.pad_leading("lorem", 10, ["$"])<br>String.pad_trailing("lorem", 10, ["$"])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>number to string</p>
            </td>
            <td>
              <p>number_string(8, String).<br>number_string(3.14, String).</p>
            </td>
            <td>
              <p>"value: " &lt;> Integer.to_string(8)<br>"value: " &lt;> Float.to_string(3.14)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>string to number</p>
            </td>
            <td>
              <p>number_string(N, "12"), X is 7 + N.<br>number_string(N, "0.039"), X is 73.9 + N.</p>
            </td>
            <td>
              <p>7 + String.to_integer("12")<br>73.9 + String.to_float("0.039")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>non-referential identifier to string</p>
            </td>
            <td>
              <p>name(foo, X).</p>
            </td>
            <td>
              <p>Atom.to_string(:foo)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>string to non-referential identifier</p>
            </td>
            <td>
              <p>string_to_atom("foo", X).</p>
            </td>
            <td>
              <p>String.to_atom("foo")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>translate case<br>to upper, to lower</p>
            </td>
            <td>
              <p>upcase_atom('lorem', X).<br>downcase_atom('LOREM', X).</p>
            </td>
            <td>
              <p>String.downcase("LOREM")<br>String.upcase("lorem")<br>String.capitalize("lorem")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>split</p>
            </td>
            <td>
              <p>split_string("foo bar baz", " ", "", Result).</p>
            </td>
            <td>
              <p>String.split("foo bar baz")<br>Regex.split(~r/ /, "foo bar baz")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>join<br></p>
            </td>
            <td>
              <p>atomics_to_string(["foo", "bar", "baz"], " ", Result).</p>
            </td>
            <td>
              <p>String.join(["foo", "bar", "baz"])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>character literal<br></p>
            </td>
            <td>
              <p>0'A (character code 65)<br>'A' (atom 'A')</p>
            </td>
            <td>
              <p>'A'</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>string length</p>
            </td>
            <td>
              <p>length("hello", X).<br><br>atom_length('hello', X).</p>
            </td>
            <td>
              <p>String.length("hello")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>index of substring<br>first, last</p>
            </td>
            <td>
              <p>sub_string("foo bar bar", CharsBefore, _, _, "bar"),<br>Index is CharsBefore + 1.<br>all solutions enumerated on backtracking: CharsBefore = 4, Index = 5 ; CharsBefore = 8, Index = 9</p>
            </td>
            <td>
              <p># {4, 3}:<br>:binary.match("foo bar baz", "bar")<br><br>??</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>extract substring</p>
            </td>
            <td>
              <p>sub_string("foo bar bar", 4, 3, _, Result).</p>
            </td>
            <td>
              <p>String.slice("foo bar baz", 5..3)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>chr and ord</p>
            </td>
            <td>
              <p>char_code(X, 65).<br>char_code('A', X).</p>
            </td>
            <td>
              <p>List.to_string([65])<br>Enum.at('A', 0)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>regular expressions</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>literal</p>
            </td>
            <td></td>
            <td>
              <p>~r/lorem|ipsum/</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>character class abbreviations</p>
            </td>
            <td></td>
            <td>
              <p>. \d \D \h \H \s \S \v \V \w \W</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>anchors<br></p>
            </td>
            <td></td>
            <td>
              <p>^ $ \A \b \B \G \z \Z</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>match test</p>
            </td>
            <td></td>
            <td>
              <p>Regex.match?(~r/.*1999/, "it's 2000")<br>String.match?("it's 2000", ~r/.*1999/)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>case insensitive match test</p>
            </td>
            <td></td>
            <td>
              <p>Regex.match?(~r/lorem/i, "Lorem")<br>String.match?("Lorem", ~r/lorem/i)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>modifiers</p>
            </td>
            <td></td>
            <td>
              <p>u i s m x f U</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>substitution</p>
            </td>
            <td></td>
            <td>
              <p>Regex.replace(~r/mi/, "do re mi mi mi", "ma")<br>String.replace("do re mi mi mi", ~r/mi/, "ma")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>match, prematch, postmatch</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>group capture</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>named group capture</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>scan</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>backreference in match</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>backreference in substitution</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>dates and time</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>current date/time</p>
            </td>
            <td>
              <p>get_time(TimeStamp), stamp_date_time(TimeStamp, date(YY,MM,DD,H,M,S,_,_,_), local).<br>get_time(TimeStamp), stamp_date_time(TimeStamp, date(YY,MM,DD,H,M,S,_,_,_), 'UTC').</p>
            </td>
            <td>
              <p>DateTime.utc_now</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>lists</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>list literal</p>
            </td>
            <td>
              <p>[1, 2, 3]</p>
            </td>
            <td>
              <p>[1, 2, 3]</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>cons</p>
            </td>
            <td>
              <p>[3, 2, 1]].</p>
            </td>
            <td>
              <p>[4 | [3, 2, 1]]</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>head</p>
            </td>
            <td>
              <p>[X | _] = [1, 2, 3].</p>
            </td>
            <td>
              <p>hd([1, 2, 3])<br>[head | _] = [1, 2, 3]<br>List.first [1, 2, 3]</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>tail</p>
            </td>
            <td>
              <p>[_ | X] = [1, 2, 3].</p>
            </td>
            <td>
              <p>tl([1, 2, 3])<br>[_ | tail] = [1, 2, 3]</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>length</p>
            </td>
            <td>
              <p>length([1, 2, 3], X).</p>
            </td>
            <td>
              <p>length([1, 2, 3])<br>Enum.count([1, 2, 3])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>append</p>
            </td>
            <td>
              <p>append([1, 2], [3, 4], List).</p>
            </td>
            <td>
              <p>[1, 2] ++ [3, 4]</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>sort</p>
            </td>
            <td>
              <p>sort([1, 3, 2, 4], X).</p>
            </td>
            <td>
              <p>Enum.sort([1, 3, 2, 4])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>reverse</p>
            </td>
            <td>
              <p>reverse([1, 2, 3, 4], X).</p>
            </td>
            <td>
              <p>Enum.reverse([1, 2, 3, 4])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>membership</p>
            </td>
            <td>
              <p>member(1, [1, 2, 3]).</p>
            </td>
            <td>
              <p>Enum.member?([1, 2, 3], 1)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>zip</p>
            </td>
            <td></td>
            <td>
              <p>Enum.zip([1, 2, 3], ["a", "b", "c"])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>map</p>
            </td>
            <td></td>
            <td>
              <p>Enum.map([1, 2, 3], fn x -> x * x end)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>filter</p>
            </td>
            <td></td>
            <td>
              <p>Enum.filter([1, 2, 3], fn x -> x > 2 end)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>reduce</p>
            </td>
            <td></td>
            <td>
              <p># 2:<br>Enum.reduce([1, 2, 3], fn x, y -> x - y end)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>tuples</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>tuple literal</p>
            </td>
            <td>
              <p>(1, "hello", 3.14) or any arbitrary function symbol</p>
            </td>
            <td>
              <p>{1, "foo", 3.14}</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>tuple element access</p>
            </td>
            <td>
              <p>arg(2, tuple(1, "foo", 3.14), Element).<br>Element = "foo".</p>
            </td>
            <td>
              <p># "foo":<br>elem({1, "foo", 3.14}, 2)<br><br># 1, "bar", 3.14}:<br>put_elem({1, "foo", 3.14}, 2, "bar")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>tuple length</p>
            </td>
            <td>
              <p>functor(tuple(1, "foo", 3.14), _, Length).<br>Length = 3.</p>
            </td>
            <td>
              <p>tuple_size({1, "foo", 3.14})</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>dictionaries</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>literal</p>
            </td>
            <td></td>
            <td>
              <p>%{"t" => 1, "f" => 0}</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>size</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>lookup</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>update</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>missing key behavior</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>is key present</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>iterate</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>algebraic data types</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>record</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>functions</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>function definition</p>
            </td>
            <td>
              <p>factorial(0,1).<br>factorial(N, F) :- N1 is N - 1, factorial(N1, F1), F is N * F1.</p>
            </td>
            <td>
              <p>def factorial(0), do: 1<br>def factorial(n), do: n * factorial(n - 1)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>function definition with guards</p>
            </td>
            <td>
              <p>factorial(N, F) :- N > 0, N1 is N - 1, factorial(N1, F1), F is N * F1.<br>factorial(0, 1).</p>
            </td>
            <td>
              <p>def factorial(n) when n > 0, do: n * factorial(n - 1)<br>def factorial(0), do: 1</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>anonymous function</p>
            </td>
            <td></td>
            <td>
              <p>fn(x, y) -> x + y end</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>piecewise defined anonymous function</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>execution control</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>if</p>
            </td>
            <td>
              <p>( X = 0 -> format('no hits~n')<br>; X = 1 -> format('one hit~n')<br>; X > 1 -> format('~w hits~n', [X]) ).</p>
            </td>
            <td>
              <p>if x == 0 do<br>IO.puts "no hits"<br>else<br>IO.puts "hits"<br>end</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>for</p>
            </td>
            <td>
              <p>between(1, 10, X), writeln(X), false; true.</p>
            </td>
            <td>
              <p>for x &lt;- 1..10, do: IO.puts(x)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>try/catch | X = 0,<br>catch(Y is 7 div X,<br>error(evaluation_error(zero_divisor), _),<br>Y is 0).</p>
            </td>
            <td>
              <p>try do<br>div(7, 0)<br>:ok<br>catch<br>_, _ -> :failed<br>end</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>receive message</p>
            </td>
            <td></td>
            <td>
              <p>receive do<br>{:ok, some_value} -> :yay<br>{:error, val} when val > 0 -> :meh<br>{:error, oh_no} -> :aw<br>end</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>spawn process</p>
            </td>
            <td>
              <p>| pid = spawn(fn -> :ok end)</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>send message</p>
            </td>
            <td></td>
            <td>
              <p>send(pid, :hello)</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>list processes</p>
            </td>
            <td></td>
            <td>
              <p>Process.list</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>file handles</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>read line from stdin</p>
            </td>
            <td></td>
            <td>
              <p># returns newline terminated string:<br>s = IO.gets("> ")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>write line to stdout</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>write line to stderr</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>open file for reading</p>
            </td>
            <td>
              <p>open('foo.txt', read, Fd).</p>
            </td>
            <td>
              <p>{:ok, f} = File.open("/etc/hosts", [:read])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>read line</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>read character</p>
            </td>
            <td>
              <p>get_char(X).</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>read term</p>
            </td>
            <td>
              <p>read(X).</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>open file for writing</p>
            </td>
            <td>
              <p>open('foo.txt', write, Fd).</p>
            </td>
            <td>
              <p>{:ok, f} = File.open("/tmp/foo.txt", [:write])</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>open file for appending</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>write line</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>write character</p>
            </td>
            <td>
              <p>put_char("A").<br>put_char(65)</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>write term | X = hello, write(X).</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>printf</p>
            </td>
            <td>
              <p>format('foo: ~s ~2f ~w~n', ["bar", 3.1415, 7]).</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>close file</p>
            </td>
            <td>
              <p>close(Fd).</p>
            </td>
            <td>
              <dl>
                <dt></dt>
                <dd>
                  <div>ok = File.close(f)</div>
                </dd>
              </dl>
            </td>
          </tr>
          <tr>
            <td>
              <p>files</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>file test, regular file test</p>
            </td>
            <td></td>
            <td>
              <p>File.regular? "/etc/hosts"</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>file size</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>directories</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>build pathname</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>dirname and basename</p>
            </td>
            <td></td>
            <td>
              <p>File.dirname "/etc/hosts"<br>File.basename "/etc/hosts"</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>absolute pathname</p>
            </td>
            <td></td>
            <td>
              <p>File.absname "/etc/hosts"</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>glob paths</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>make directory</p>
            </td>
            <td></td>
            <td>
              <p>File.mkdir_p("/tmp/foo/bar")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>directory test</p>
            </td>
            <td></td>
            <td>
              <p>File.dir? "/tmp"</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>processes and environment</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>command line arguments</p>
            </td>
            <td>
              <p>binds Argv to list of atoms representing command line args:<br>current_prolog_flag(argv, Argv).</p>
            </td>
            <td>
              <p>System.argv</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>program name</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>exit</p>
            </td>
            <td>
              <p>halt(1).</p>
            </td>
            <td>
              <p>System.halt</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>libraries and namespaces</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>load file</p>
            </td>
            <td>
              <p>ways to load file data.pl:<br>[data].<br>['data.pl'].<br>consult(data)</p>
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>define namespace</p>
            </td>
            <td>
              <dl>
                <dt></dt>
                <dd>
                  <div>- module(factorial, [factorial/1]).</div>
                </dd>
              </dl>
            </td>
            <td>
              <p>defmodule Factorial do<br>end</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>compile namespace</p>
            </td>
            <td></td>
            <td>
              <p>c("factorial.ex")</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>use function in namespace</p>
            </td>
            <td></td>
            <td>
              <p>Factorial.fact 7</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>reflection</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>prolog</p>
            </td>
            <td>
              <p>elixir</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>inspect namespace</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>repl</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>help</p>
            </td>
            <td>
              <p>help.<br>apropos(keyword).</p>
            </td>
            <td>
              <p>h</p>
            </td>
          </tr>
          <tr>
            <td>
              <p>clear variable</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>clear all variables</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>
              <p>display processes</p>
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td></td>
            <td>
              <p>__________________________________________________________________________</p>
            </td>
            <td>
              <p>_________________________________________________________</p>
            </td>
          </tr>
        </tbody>
      </table>
    </figure>
  </body>
</html>
